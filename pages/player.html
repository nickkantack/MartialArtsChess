<!DOCTYPE html>
<html>
    <head>
        <title>Player</title>
        <link rel="stylesheet" href="../styles/style.css"/>
        <script src="../scripts/Base.js"></script>
        <script src="../scripts/Game.js"></script>
        <script src="../scripts/MartialArtsChess.js"></script>
    </head>
    <body>
        <button id="commitMoves">Commit moves</button>
        <div id="debug"></div>
        <div id="originDiv"></div>
        <div id="moveDrawingDiv"></div>
        <template id="mainBoardSquareTemplate">
            <svg class="mainBoardSquare" viewBox="0 0 100 100">
                <path stroke="#AA9" stroke-width="3px" fill="#FFC" d="M0 0H100V100H0Z" />
            </svg>
        </template>
        <template id="moveDrawingSquareTemplate">
            <svg class="moveDrawingSquare" viewBox="0 0 100 100">
                <path stroke="#AA9" stroke-width="3px" fill="#FFC" d="M0 0H100V100H0Z" />
            </svg>
        </template>
        <template id="aPawnTemplate">
            <svg class="aPawn">
                <path stroke="#933" stroke-width="3px" fill="#F55" d="M20 20H80V80H20Z" />
            </svg>
        </template>
        <template id="bPawnTemplate">
            <svg class="bPawn">
                <path stroke="#339" stroke-width="3px" fill="#55F" d="M20 20H80V80H20Z" />
            </svg>
        </template>
        <template id="aGuruTemplate">
            <svg class="aGuru">
                <path stroke="#933" stroke-width="3px" fill="#F55" d="M50 20L20 80H80Z" />
            </svg>
        </template>
        <template id="bGuruTemplate">
            <svg class="bGuru">
                <path stroke="#339" stroke-width="3px" fill="#55F" d="M50 20L20 80H80Z" />
            </svg>
        </template>
        <script>
            const debug = document.getElementById("debug");
            const originDiv = document.getElementById("originDiv");
            const moveDrawingDiv = document.getElementById("moveDrawingDiv");
            const mainBoardSquareTemplate = document.getElementById("mainBoardSquareTemplate");
            const moveDrawingSquareTemplate = document.getElementById("moveDrawingSquareTemplate");
            const aPawnTemplate = document.getElementById("aPawnTemplate");
            const bPawnTemplate = document.getElementById("bPawnTemplate");
            const aGuruTemplate = document.getElementById("aGuruTemplate");
            const bGuruTemplate = document.getElementById("bGuruTemplate");
            const commitMovesButton = document.getElementById("commitMoves");
            let currentMouseCoordinatesOverBoard = null;
            let mainBoardUnitLength = 100;
            let moveDrawingSquareUnitLength = 20;

            let pieceStartingBoardCoordinates = null;
            let selectedPiece = null;
            let selectedMove = null;

            let game = null;

            let isLockedIn = false;

            document.body.addEventListener("mousemove", (event) => {
                debug.innerHTML = `${event.clientX - originDiv.offsetLeft}, ${event.clientY - originDiv.offsetTop}`;   
                if (mainBoardUnitLength) {
                    currentMouseCoordinatesOverBoard = [parseInt((event.clientX - originDiv.offsetLeft) / mainBoardUnitLength + 2.5),
                        -parseInt((event.clientY - originDiv.offsetTop) / mainBoardUnitLength - 2.5)];
                    debug.innerHTML += `<br/>${currentMouseCoordinatesOverBoard[0]},${currentMouseCoordinatesOverBoard[1]}`;
                }
                if (selectedPiece) {
                    let computedSyle = window.getComputedStyle(selectedPiece);
                    let matrix = new WebKitCSSMatrix(computedSyle.transform);
                    selectedPiece.style.transform = `translate(${matrix.m41 + event.movementX}px, ${matrix.m42 + event.movementY}px)`;
                }
            });

            // Create main board
            for (let i = 0; i <= 4; i++) {
                for (let j = 0; j <= 4; j++) {
                    const mainSquare = mainBoardSquareTemplate.content.cloneNode(true).querySelector(".mainBoardSquare");
                    // TODO support Chrome, which fails getting the unitLength as shown below
                    const unitLength = mainBoardUnitLength;
                    mainSquare.style.transform = `translate(${(-2.5 + i) * unitLength}px, ${(-2.5 + j) * unitLength}px)`;
                    mainSquare.id = `mainSquare-${i},${j}`;
                    document.body.appendChild(mainSquare);
                }
            }

            // Create the move drawing grids
            for (let k = 0; k <= 4; k++) {
                for (let i = 0; i <= 4; i++) {
                    for (let j = 0; j <= 4; j++) {
                        const moveDrawingSquare = moveDrawingSquareTemplate.content.cloneNode(true).querySelector(".moveDrawingSquare");
                        // TODO support Chrome, which fails getting the unitLength as shown below
                        const unitLength = moveDrawingSquareUnitLength;
                        moveDrawingSquare.style.transform = `translate(${(-2.5 + i) * unitLength}px, ${(2.5 + j + 7 * k) * unitLength}px)`;
                        moveDrawingSquare.id = `moveDrawingSquare-${k},${i},${j}`;
                        if (i === 2 && j === 2) {
                            moveDrawingSquare.querySelector("path").setAttribute("fill", "#333");
                        } else {
                            moveDrawingSquare.addEventListener("mousedown", () => {
                                if (isLockedIn) {
                                    if (k < 2 && game.playerTurnIndex === 0) {
                                        console.warn("That move belongs to the blue player, and it's the red player's turn.");
                                        return;
                                    }
                                    if (k === 2) {
                                        console.warn("That move belongs to neither player.");
                                        return;
                                    }
                                    if (k >= 3 && game.playerTurnIndex === 1) {
                                        console.warn("That move belongs to the red player, and it's the blue player's turn.");
                                        return;
                                    }
                                    // Need to use k as the index in aMoves or bMoves to get the right move
                                    if (k < 2) {
                                        if (k === 0) selectedMove = game.bMoves[1];
                                        if (k === 1) selectedMove = game.bMoves[0];
                                    } else {
                                        if (k === 3) selectedMove = game.aMoves[1];
                                        if (k === 4) selectedMove = game.aMoves[0];
                                    }
                                    console.log(`Selected move ${selectedMove}`);
                                } else {
                                    if (moveDrawingSquare.querySelector("path").getAttribute("fill") === "#77A") {
                                        moveDrawingSquare.querySelector("path").setAttribute("fill", "#FFC");
                                    } else {
                                        moveDrawingSquare.querySelector("path").setAttribute("fill", "#77A");
                                    }
                                }
                            });
                        }
                        moveDrawingDiv.appendChild(moveDrawingSquare);
                    }
                }
            }
            
            // Create the pieces
            for (let playerIndex = 0; playerIndex <= 1; playerIndex++) {

                for (let i = 0; i <= 4; i++) {
                    let pawn;
                    if (i === 2) {
                        pawn = playerIndex ? bGuruTemplate.content.cloneNode(true).querySelector(".bGuru") : aGuruTemplate.content.cloneNode(true).querySelector(".aGuru");
                    } else {
                        pawn = playerIndex ? bPawnTemplate.content.cloneNode(true).querySelector(".bPawn") : aPawnTemplate.content.cloneNode(true).querySelector(".aPawn");
                    }
                    pawn.id = `${playerIndex ? "b" : "a"}${i}`;
                    pawn.style.transform = `translate(${(-2.5 + i) * mainBoardUnitLength}px, ${(-2.5 + (playerIndex ? 0 : 4)) * mainBoardUnitLength}px)`;
                    pawn.addEventListener("mousedown", (event) => {
                        if (playerIndex === 1 && isLockedIn && pawn.id === "a") {
                            console.warn("It is the blue player's turn");
                            return;
                        }
                        if (playerIndex === 0 && isLockedIn && pawn.id === "b") {
                            console.warn("It is the red player's turn");
                            return;
                        }
                        if (isLockedIn && !selectedMove) {
                            console.warn("You must select a move before manipulating a piece.");
                            return;
                        }
                        selectedPiece = pawn;
                        // TODO give this piece a higher z index than all other piece svgs so that it's mouseup
                        // event is the one that fires when it is released.
                        const dummyEnd = document.createElement("div");
                        document.body.appendChild(dummyEnd);
                        document.body.insertBefore(pawn, dummyEnd);
                        document.body.removeChild(dummyEnd);
                        pieceStartingBoardCoordinates = getSvgPositionAsBoardCoordinates(pawn);
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${matrix.m41 + event.offsetX - (pawn.getBoundingClientRect().right - pawn.getBoundingClientRect().left) / 2}px, ${matrix.m42 + event.offsetY - (pawn.getBoundingClientRect().bottom - pawn.getBoundingClientRect().top) / 2}px)`;
                    });
                    pawn.addEventListener("mouseup", () => {
                        if (playerIndex === 1 && isLockedIn && /a/.test(pawn.id)) {
                            return;
                        }
                        if (playerIndex === 0 && isLockedIn && /b/.test(pawn.id)) {
                            return;
                        }
                        if (isLockedIn && !selectedMove) {
                            return;
                        }
                        selectedPiece = null;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        const dropDestinationCoordinates = [parseInt(matrix.m41 / mainBoardUnitLength + 3), 4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)];
                        pawn.style.transform = `translate(${(parseInt(matrix.m41 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px, ${(parseInt(matrix.m42 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px)`;
                        console.log(`Picked up a piece at ${pieceStartingBoardCoordinates}`);
                        console.log(`Want to place piece at ${dropDestinationCoordinates}`);
                        // If there is a piece here already, move it off the board
                        for (let letter of ["a", "b"]) {
                            for (let i = 0; i <= 4; i++) {
                                const idOfPotentiallyCapturedPiece = `${letter}${i}`;
                                if (idOfPotentiallyCapturedPiece === pawn.id) continue;
                                const potentiallyCapturedSvg = document.getElementById(idOfPotentiallyCapturedPiece);
                                const coordinates = getSvgPositionAsBoardCoordinates(potentiallyCapturedSvg);
                                if (coordinates[0] === dropDestinationCoordinates[0] && coordinates[1] === dropDestinationCoordinates[1]) {
                                    console.log("There was already a piece here, so it is now captured");
                                    potentiallyCapturedSvg.style.transform = getBoardCoordinatesAsSvgTransform(5, 0);
                                    break;
                                }
                            }
                        }
                        if (!isLockedIn) return;
                        const destinationCoordinates = [parseInt(matrix.m41 / mainBoardUnitLength + 3), 4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)];
                        const destinationCoordinatesAsString = `${destinationCoordinates[0]},${destinationCoordinates[1]}`;
                        const relativeMoveAttempted = [parseInt(matrix.m41 / mainBoardUnitLength + 3) - pieceStartingBoardCoordinates[0], 4 - parseInt(matrix.m42 / mainBoardUnitLength + 3) - pieceStartingBoardCoordinates[1]];
                        // TODO if the blue player is making the move, reflect the coordinates of the relative move computed above
                        if (game.playerTurnIndex) {
                            relativeMoveAttempted[0] *= -1;
                            relativeMoveAttempted[1] *= -1;
                        }
                        console.log(`Relative move attempted was ${relativeMoveAttempted}`);
                        console.log(`The selected move allows ${game.serialToRelativeMoveMap[selectedMove]}`);
                        let wasRelativeMoveFound = false;
                        for (let relativeMove of game.serialToRelativeMoveMap[selectedMove]) {
                            if (relativeMove[0] === relativeMoveAttempted[0] && relativeMove[1] === relativeMoveAttempted[1]) {
                                wasRelativeMoveFound = true;
                                console.log(game.squareToSerialMap);
                                const moveString = [pawn.id, selectedMove, game.cMove, relativeMoveAttempted, game.squareToSerialMap[destinationCoordinatesAsString] ? game.squareToSerialMap[destinationCoordinatesAsString] : null];
                                console.log(`Would submit this turn ${moveString}`);
                                let legalMoves = game.getMoves();
                                let didFindMatchingLegalMove = false;
                                for (let move of legalMoves) {
                                    if (doMovesMatch(move, moveString)) {
                                        didFindMatchingLegalMove = true;
                                        break;
                                    }
                                }
                                if (didFindMatchingLegalMove) {
                                    console.log("That is a legal move!");
                                    game.makeMove(moveString);
                                    // Sync the UI with the new game state
                                    redrawMovesBasedOnCurrentMap();
                                    applyGamePiecePositionsToUi();
                                    selectedMove = null;
                                } else {
                                    console.warn(`Did not find that in the list of legal moves: ${legalMoves}`);
                                    return;
                                }
                                break;
                            }
                        }
                        if (!wasRelativeMoveFound) {
                            console.warn("You are not allowed to make that move");
                            pawn.style.transform = getBoardCoordinatesAsSvgTransform(pieceStartingBoardCoordinates);
                        }
                    });
                    document.body.appendChild(pawn);
                }
            }

            commitMoves.addEventListener("click", () => {
        
                if (isLockedIn) {
                    // Nothing to do
                    commitMoves.innerHTML = "Edit game";
                } else {
                    // construct moves from the move svgs
                    const moveArrayForGameInstantiation = [];
                    for (let k = 0; k <= 4; k++) {
                        const relativeMoveArray = [];
                        for (let i = 0; i <= 4; i++) {
                            for (let j = 0; j <= 4; j++) {
                                const svg = document.getElementById(`moveDrawingSquare-${4 - k},${i},${j}`);
                                if (svg.querySelector("path").getAttribute("fill") === "#77A") {
                                    // We want the center move drawing to be ultimately coded as the cMove, 
                                    // which means it needs to be last in the constructor arguments. So,
                                    // once we have iterated up to k === 2 (the cMove), we will start inserting
                                    // subsequent moves before the cMove so that it is last.
                                    relativeMoveArray.push([i - 2, 2 - j]);
                                }
                            }
                        }
                        if (k > 2) {
                            moveArrayForGameInstantiation.splice(k - 1, 0, relativeMoveArray);
                        } else {
                            moveArrayForGameInstantiation.push(relativeMoveArray);
                        }
                    }
                    // instantiate the game
                    console.log(moveArrayForGameInstantiation);
                    game = new MartialArtsChess(moveArrayForGameInstantiation);
                    applyUiPiecePositionsToGame();
                    redrawMovesBasedOnCurrentMap();
                    commitMoves.innerHTML = "Commit game state";
                }
                isLockedIn = !isLockedIn;

            });

            function applyUiPiecePositionsToGame() {
                // First, we need to empty the maps since we'll manually add everything
                for (let key of Object.keys(game.aSerialToSquareMap)) {
                    delete game.aSerialToSquareMap[key];
                }
                for (let key of Object.keys(game.bSerialToSquareMap)) {
                    delete game.bSerialToSquareMap[key];
                }
                for (let key of Object.keys(game.squareToSerialMap)) {
                    delete game.squareToSerialMap[key];
                }
                for (let i = 0; i <= 4; i++) {
                    const pieceSerial = `a${i}`;
                    const aPiece = document.getElementById(pieceSerial);
                    const boardCoordinates = getSvgPositionAsBoardCoordinates(aPiece);
                    if (boardCoordinates[0] >= 0 && boardCoordinates[0] <= 4 && boardCoordinates[1] >= 0 && boardCoordinates[1] <= 4) {
                        game.aSerialToSquareMap[pieceSerial] = boardCoordinates;
                        const boardCoordinatesAsString = `${boardCoordinates[0]},${boardCoordinates[1]}`;
                        game.squareToSerialMap[boardCoordinatesAsString] = pieceSerial;
                    } else {
                        // Assume the piece is captured because it is off the board
                    }
                }
                for (let i = 0; i <= 4; i++) {
                    const pieceSerial = `b${i}`;
                    const bPiece = document.getElementById(pieceSerial);
                    const boardCoordinates = getSvgPositionAsBoardCoordinates(bPiece);
                    if (boardCoordinates[0] >= 0 && boardCoordinates[0] <= 4 && boardCoordinates[1] >= 0 && boardCoordinates[1] <= 4) {
                        game.bSerialToSquareMap[pieceSerial] = boardCoordinates;
                        const boardCoordinatesAsString = `${boardCoordinates[0]},${boardCoordinates[1]}`;
                        game.squareToSerialMap[boardCoordinatesAsString] = pieceSerial;
                    } else {
                        // Assume the piece is captured because it is off the board
                    }
                }
            }

            function applyGamePiecePositionsToUi() {
                for (let i = 0; i <= 4; i++) {
                    const aPieceSerial = `a${i}`;
                    const bPieceSerial = `b${i}`;
                    const svgA = document.getElementById(aPieceSerial);
                    if (game.aSerialToSquareMap.hasOwnProperty(aPieceSerial)) {
                        svgA.style.transform = getBoardCoordinatesAsSvgTransform(game.aSerialToSquareMap[aPieceSerial]);
                    } else {
                        // Move the piece off-board because it is captured
                        svgA.style.transform = getBoardCoordinatesAsSvgTransform(5, 0);
                    }
                    const svgB = document.getElementById(bPieceSerial);
                    if (game.bSerialToSquareMap.hasOwnProperty(bPieceSerial)) {
                        svgB.style.transform = getBoardCoordinatesAsSvgTransform(game.bSerialToSquareMap[bPieceSerial]);
                    } else {
                        // Move the piece off board because it is captured
                        svgB.style.transform = getBoardCoordinatesAsSvgTransform(5, 4);
                    }
                }
            }

            function redrawMovesBasedOnCurrentMap() {
                // Decolor all of them first
                for (let square of document.querySelectorAll(".moveDrawingSquare")) {
                    if (!/.*2,2$/.test(square.id)) {
                        square.querySelector("path").setAttribute("fill", "#FFC");
                    }
                }
                console.log(game.aMoves);
                console.log(game.bMoves);
                console.log(game.serialToRelativeMoveMap);
                let k = 0;
                for (let move of game.aMoves) {
                    for (let relativeMove of game.serialToRelativeMoveMap[move]) {
                        document.getElementById(`moveDrawingSquare-${4 - k},${2 + relativeMove[0]},${2 - relativeMove[1]}`).querySelector("path").setAttribute("fill", "#77A");
                    }
                    k++;
                }
                for (let relativeMove of game.serialToRelativeMoveMap[game.cMove]) {
                    document.getElementById(`moveDrawingSquare-${4 - k},${2 + relativeMove[0]},${2 - relativeMove[1]}`).querySelector("path").setAttribute("fill", "#77A");
                }
                k++
                for (let move of game.bMoves) {
                    for (let relativeMove of game.serialToRelativeMoveMap[move]) {
                        document.getElementById(`moveDrawingSquare-${4 - k},${2 + relativeMove[0]},${2 - relativeMove[1]}`).querySelector("path").setAttribute("fill", "#77A");
                    }
                    k++;
                }
            }

            function getSvgPositionAsBoardCoordinates(svg) {
                let computedSyle = window.getComputedStyle(svg);
                let matrix = new WebKitCSSMatrix(computedSyle.transform);
                return [parseInt(matrix.m41 / mainBoardUnitLength + 3), 4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)];
            }

            function getBoardCoordinatesAsSvgTransform(i, j) {
                return `translate(${(-2.5 + i) * mainBoardUnitLength}px, ${(1.5 - j) * mainBoardUnitLength}px)`;
            }

            function doMovesMatch(moveA, moveB) {
                return moveA[0] === moveB[0] &&
                    moveA[1] === moveB[1] &&
                    moveA[2] === moveB[2] &&
                    moveA[3][0] === moveB[3][0] &&
                    moveA[3][1] === moveB[3][1] &&
                    moveA[4] === moveB[4] &&
                    moveA.length === moveB.length;
            }
        </script>
    </body>
</html>