<!DOCTYPE html>
<html>
    <head>
        <title>Player</title>
        <link rel="stylesheet" href="../styles/style.css"/>
        <script src="../scripts/Base.js"></script>
        <script src="../scripts/Game.js"></script>
        <script src="../scripts/MartialArtsChess.js"></script>
    </head>
    <body>
        <div id="debug"></div>
        <div id="controls">
            <input type="checkbox" id="showSuggestionsForRed"/>Computer hints for red player</br>
            <input type="checkbox" id="showSuggestionsForBlue"/>Computer hints for blue player<br/>
            <div id="userMessage"></div>

        </div>
        <div id="originDiv"></div>
        <div id="moveDrawingDiv">
            <button id="commitMoves">Commit moves</button>
            <svg id="selectedMoveArrow" viewBox="0 0 100 100">
                <path stroke="none" fill="#333" d="M0 50 L50 30 V40 H80 V60 H50 V70 Z"/>
            </svg>
            <svg id="yourMoveBox" viewBox="0 0 100 200">
                <path stroke="#F55" fill="none" stroke-width="5" d="M0 0 H100 V200 H0 Z"/>
            </svg>
            <svg id="otherPlayerMoveBox" viewBox="0 0 100 200">
                <path stroke="#55F" fill="none" stroke-width="5" d="M0 0 H100 V200 H0 Z"/>
            </svg>
            <svg id="moveSuggestionBox" viewBox="0 0 100 100">
                <path stroke="#55F" fill="none" stroke-width="15" opacity="0.3" d="M0 0 H100 V100 H0 Z"/>
            </svg>
        </div>
        <template id="mainBoardSquareTemplate">
            <svg class="mainBoardSquare" viewBox="0 0 100 100">
                <path stroke="#AA9" stroke-width="3px" fill="#FFC" d="M0 0H100V100H0Z" />
            </svg>
        </template>
        <template id="moveDrawingSquareTemplate">
            <svg class="moveDrawingSquare" viewBox="0 0 100 100">
                <path stroke="#AA9" stroke-width="3px" fill="#FFC" d="M0 0H100V100H0Z" />
            </svg>
        </template>
        <template id="aPawnTemplate">
            <svg class="aPawn">
                <path stroke="#933" stroke-width="3px" fill="#F55" d="M20 20H80V80H20Z" />
            </svg>
        </template>
        <template id="bPawnTemplate">
            <svg class="bPawn">
                <path stroke="#339" stroke-width="3px" fill="#55F" d="M20 20H80V80H20Z" />
            </svg>
        </template>
        <template id="aGuruTemplate">
            <svg class="aGuru">
                <path stroke="#933" stroke-width="3px" fill="#F55" d="M50 20L20 80H80Z" />
            </svg>
        </template>
        <template id="bGuruTemplate">
            <svg class="bGuru">
                <path stroke="#339" stroke-width="3px" fill="#55F" d="M50 20L20 80H80Z" />
            </svg>
        </template>
        <svg id="redPartOfEvaluationBar" viewBox="0 0 100 100">
            <path stroke="none" fill="#F55" d="M0 0H10 V100 H0 Z"/>
        </svg>
        <svg id="bluePartOfEvaluationBar" viewBox="0 0 100 100">
            <path stroke="none" fill="#55F" d="M0 0H10 V50 H0 Z"/>
        </svg>
        <svg id="blueWinProbabilityText" viewBox="0 0 100 100">
            <text x="0" y="50" style="font: 24px Tahoma; fill: #FFF">50%</text>
        </svg>
        <svg id="moveSuggestionCircle" viewBox="-0.5 -0.5 5 5">
            <circle cx="3" cy="3" r="0.4" stroke="#55F" stroke-width="0.1" opacity="0.3" />
        </svg>
        <svg id="moveSuggestionLine" viewBox="-0.5 -0.5 5 5">
            <path stroke="#55F" stroke-width="0.1" opacity="0.3" d="M0 0 L3 3"/>
        </svg>
        <script>

            const HOW_TO_EDIT_INSTRUCTIONS = `
                Click on the boxes to the left to create move cards for this game. Then click "Commit moves"
                in the upper left corner.
                `;
            const SELECT_A_MOVE_INSTRUCTIONS_PREPEND = `
                Select a move from the `;
            const SELECT_A_MOVE_INSTRUCTIONS_SUFFIX = ` box on the right.`;
            const MOVE_A_PIECE_INSTRUCTIONS = `Click an drag a piece to its new square to finish this move. Or, select a different move from the left.`;

            const debug = document.getElementById("debug");
            const originDiv = document.getElementById("originDiv");
            const moveDrawingDiv = document.getElementById("moveDrawingDiv");
            const mainBoardSquareTemplate = document.getElementById("mainBoardSquareTemplate");
            const moveDrawingSquareTemplate = document.getElementById("moveDrawingSquareTemplate");
            const aPawnTemplate = document.getElementById("aPawnTemplate");
            const bPawnTemplate = document.getElementById("bPawnTemplate");
            const aGuruTemplate = document.getElementById("aGuruTemplate");
            const bGuruTemplate = document.getElementById("bGuruTemplate");
            const commitMovesButton = document.getElementById("commitMoves");
            const moveSuggestionCircle = document.getElementById("moveSuggestionCircle");
            const moveSuggestionLine = document.getElementById("moveSuggestionLine");
            const moveSuggestionBox = document.getElementById("moveSuggestionBox");
            let currentMouseCoordinatesOverBoard = null;
            let mainBoardUnitLength = 100;
            let moveDrawingSquareUnitLength = 20;

            let pieceStartingBoardCoordinates = null;
            let selectedPiece = null;
            let selectedMove = null;

            let game = null;
            let moveArrayForGameInstantiation = [];
            let moveCount = [0];
            let moveHistory = [];
            let previousTouch = null;

            let isLockedIn = false;

            userMessage.innerHTML = HOW_TO_EDIT_INSTRUCTIONS;

            showSuggestionsForRed.checked = true;
            showSuggestionsForBlue.checked = true;
            showSuggestionsForRed.addEventListener("change", () => {
                if (showSuggestionsForRed.checked && game && game.playerTurnIndex === 0) {
                    produceComputerSuggestion();
                } else {
                    hideMoveAnnotation();
                }
            });
            showSuggestionsForBlue.addEventListener("change", () => {
                if (showSuggestionsForBlue.checked && game && game.playerTurnIndex === 1) {
                    produceComputerSuggestion();
                } else {
                    hideMoveAnnotation();
                }
            });

            document.addEventListener("keydown", (e) => {
                e.preventDefault();
                if (e.keyCode === 37) {
                    if (moveCount[0] > 0) {
                        game.unmakeMove(moveHistory[moveCount[0] - 1]);
                        moveCount[0]--;
                        console.log(game.aSerialToSquareMap);
                        redrawMovesBasedOnCurrentMap();
                        applyGamePiecePositionsToUi();
                        hideMoveAnnotation();
                        produceComputerSuggestion();
                    }
                }
                if (e.keyCode === 39) {
                    if (moveCount[0] < moveHistory.length) {
                        game.makeMove(moveHistory[moveCount[0]]);
                        moveCount[0]++;
                        redrawMovesBasedOnCurrentMap();
                        applyGamePiecePositionsToUi();
                        hideMoveAnnotation();
                        produceComputerSuggestion();
                    }
                }
            });

            function mousemove(event) {

                if (!event.movementX) {
                    event.movementX = previousTouch ? event.pageX - previousTouch.pageX : 0;
                    event.movementY = previousTouch ? event.pageY - previousTouch.pageY : 0;
                    previousTouch = event;
                }

                // debug.innerHTML = `${event.clientX - originDiv.offsetLeft}, ${event.clientY - originDiv.offsetTop}`;   
                if (mainBoardUnitLength) {
                    currentMouseCoordinatesOverBoard = [parseInt((event.clientX - originDiv.offsetLeft) / mainBoardUnitLength + 2.5),
                        -parseInt((event.clientY - originDiv.offsetTop) / mainBoardUnitLength - 2.5)];
                    // debug.innerHTML += `<br/>${currentMouseCoordinatesOverBoard[0]},${currentMouseCoordinatesOverBoard[1]}`;
                }
                if (selectedPiece) {
                    console.log(event.movementX);
                    let computedSyle = window.getComputedStyle(selectedPiece);
                    let matrix = new WebKitCSSMatrix(computedSyle.transform);
                    selectedPiece.style.transform = `translate(${matrix.m41 + event.movementX}px, ${matrix.m42 + event.movementY}px)`;
                }
            };
            document.body.addEventListener("mousemove", mousemove);
            document.body.addEventListener("touchmove", (event) => {
                mousemove(event.touches[0]);
            });

            // Create main board
            for (let i = 0; i <= 4; i++) {
                for (let j = 0; j <= 4; j++) {
                    const mainSquare = mainBoardSquareTemplate.content.cloneNode(true).querySelector(".mainBoardSquare");
                    // TODO support Chrome, which fails getting the unitLength as shown below
                    const unitLength = mainBoardUnitLength;
                    mainSquare.style.transform = `translate(${(-2.5 + i) * unitLength}px, ${(-2.5 + j) * unitLength}px)`;
                    mainSquare.id = `mainSquare-${i},${j}`;
                    document.body.insertBefore(mainSquare, moveSuggestionCircle);
                }
            }

            // Right-size the move suggestion divs
            moveSuggestionCircle.setAttribute("width", 5 * mainBoardUnitLength);
            moveSuggestionCircle.style.transform = `translate(-${2.5 * mainBoardUnitLength}px, -${2.5 * mainBoardUnitLength}px)`;
            moveSuggestionLine.setAttribute("width", 5 * mainBoardUnitLength);
            moveSuggestionLine.style.transform = `translate(-${2.5 * mainBoardUnitLength}px, -${2.5 * mainBoardUnitLength}px)`;
            moveSuggestionBox.setAttribute("width", 7 * moveDrawingSquareUnitLength);
            moveSuggestionBox.style.transform = `translate(-${3.5 * moveDrawingSquareUnitLength}px, ${1.5 * moveDrawingSquareUnitLength}px)`;
            yourMoveBox.setAttribute("width", 7 * moveDrawingSquareUnitLength);
            yourMoveBox.style.transform = `translate(-${3.5 * moveDrawingSquareUnitLength}px, ${22.5 * moveDrawingSquareUnitLength}px)`;
            otherPlayerMoveBox.setAttribute("width", 7 * moveDrawingSquareUnitLength);
            otherPlayerMoveBox.style.transform = `translate(-${3.5 * moveDrawingSquareUnitLength}px, ${1.5 * moveDrawingSquareUnitLength}px)`;
            selectedMoveArrow.setAttribute("width", 3 * moveDrawingSquareUnitLength);
            selectedMoveArrow.style.transform = `translate(${3.5 * moveDrawingSquareUnitLength}px, 0px)`;

            redPartOfEvaluationBar.setAttribute("height", 5 * mainBoardUnitLength);
            redPartOfEvaluationBar.style.transform = `translate(${4 * mainBoardUnitLength}px, ${-2.5 * mainBoardUnitLength}px)`;
            bluePartOfEvaluationBar.setAttribute("height", 5 * mainBoardUnitLength);
            bluePartOfEvaluationBar.style.transform = `translate(${4 * mainBoardUnitLength}px, ${-2.5 * mainBoardUnitLength}px)`;
            blueWinProbabilityText.style.transform = `translate(${4 * mainBoardUnitLength}px, ${-2.5 * mainBoardUnitLength - 20}px)`;


            // Create the move drawing grids
            for (let k = 0; k <= 4; k++) {
                for (let i = 0; i <= 4; i++) {
                    for (let j = 0; j <= 4; j++) {
                        const moveDrawingSquare = moveDrawingSquareTemplate.content.cloneNode(true).querySelector(".moveDrawingSquare");
                        // TODO support Chrome, which fails getting the unitLength as shown below
                        const unitLength = moveDrawingSquareUnitLength;
                        moveDrawingSquare.style.transform = `translate(${(-2.5 + i) * unitLength}px, ${(2.5 + j + 7 * k) * unitLength}px)`;
                        moveDrawingSquare.id = `moveDrawingSquare-${k},${i},${j}`;
                        if (i === 2 && j === 2) {
                            moveDrawingSquare.querySelector("path").setAttribute("fill", "#333");
                        } else {
                            moveDrawingSquare.addEventListener("mousedown", () => {
                                if (isLockedIn) {
                                    if (k < 2 && game.playerTurnIndex === 0) {
                                        console.warn("That move belongs to the blue player, and it's the red player's turn.");
                                        sendMessage("That move belongs to the blue player, and it's the red player's turn. Click and drag a piece to complete this player's turn, or select a different move from the left.");
                                        return;
                                    }
                                    if (k === 2) {
                                        sendMessage("That move belongs to neither player, and it's the red player's turn. Click and drag a piece to complete this player's turn, or select a different move from the left.");
                                        return;
                                    }
                                    if (k >= 3 && game.playerTurnIndex === 1) {
                                        console.warn("That move belongs to the red player, and it's the blue player's turn.");
                                        sendMessage("That move belongs to the red player, and it's the blue player's turn. Click and drag a piece to complete this player's turn, or select a different move from the left.");
                                        return;
                                    }
                                    // Need to use k as the index in aMoves or bMoves to get the right move
                                    const reflectedK = 4 - k;
                                    selectedMoveArrow.style.transform = `translate(${3.5 * moveDrawingSquareUnitLength}px, ${(k * 7 + 3.5) * moveDrawingSquareUnitLength}px)`;
                                    selectedMoveArrow.style.display = "block";
                                    if (reflectedK === 0) selectedMove = game.aMoves[0];
                                    if (reflectedK === 1) selectedMove = game.aMoves[1];
                                    if (reflectedK === 3) selectedMove = game.bMoves[0];
                                    if (reflectedK === 4) selectedMove = game.bMoves[1];
                                    console.log(`Selected move ${selectedMove}`);
                                    sendMessage("Click and drag a piece to complete this player's turn, or select a different move from the left.");
                                } else {
                                    if (moveDrawingSquare.querySelector("path").getAttribute("fill") === "#77A") {
                                        moveDrawingSquare.querySelector("path").setAttribute("fill", "#FFC");
                                    } else {
                                        moveDrawingSquare.querySelector("path").setAttribute("fill", "#77A");
                                    }
                                }
                            });
                        }
                        moveDrawingDiv.appendChild(moveDrawingSquare);
                    }
                }
            }
            
            // Create the pieces
            for (let playerIndex = 0; playerIndex <= 1; playerIndex++) {

                for (let i = 0; i <= 4; i++) {
                    let pawn;
                    if (i === 2) {
                        pawn = playerIndex ? bGuruTemplate.content.cloneNode(true).querySelector(".bGuru") : aGuruTemplate.content.cloneNode(true).querySelector(".aGuru");
                    } else {
                        pawn = playerIndex ? bPawnTemplate.content.cloneNode(true).querySelector(".bPawn") : aPawnTemplate.content.cloneNode(true).querySelector(".aPawn");
                    }
                    pawn.id = `${playerIndex ? "b" : "a"}${i}`;
                    pawn.style.transform = `translate(${(-2.5 + i) * mainBoardUnitLength}px, ${(-2.5 + (playerIndex ? 0 : 4)) * mainBoardUnitLength}px)`;
                    function mousedown(event) {
                        if (game && game.playerTurnIndex === 1 && isLockedIn && /a/.test(pawn.id)) {
                            sendMessage("That piece can't move. It is the blue player's turn.");
                            return;
                        }
                        if (game && game.playerTurnIndex === 0 && isLockedIn && /b/.test(pawn.id)) {
                            sendMessage("That piece can't move. It is the red player's turn.");
                            return;
                        }
                        if (isLockedIn && !selectedMove) {
                            sendMessage("You must select a move before manipulating a piece.");
                            console.warn("You must select a move before manipulating a piece.");
                            return;
                        }
                        selectedPiece = pawn;
                        // TODO give this piece a higher z index than all other piece svgs so that it's mouseup
                        // event is the one that fires when it is released.
                        document.body.insertBefore(pawn, moveSuggestionLine);
                        pieceStartingBoardCoordinates = getSvgPositionAsBoardCoordinates(pawn);
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${matrix.m41 + event.offsetX - (pawn.getBoundingClientRect().right - pawn.getBoundingClientRect().left) / 2}px, ${matrix.m42 + event.offsetY - (pawn.getBoundingClientRect().bottom - pawn.getBoundingClientRect().top) / 2}px)`;
                    };
                    pawn.addEventListener("mousedown", mousedown);
                    pawn.addEventListener("touchstart", (event) => {
                        event.preventDefault();
                        mousedown(event.touches[0]);
                    });
                    function mouseup(event) {
                        previousTouch = null;
                        if (playerIndex === 1 && isLockedIn && /a/.test(pawn.id)) {
                            return;
                        }
                        if (playerIndex === 0 && isLockedIn && /b/.test(pawn.id)) {
                            return;
                        }
                        if (isLockedIn && !selectedMove) {
                            return;
                        }
                        selectedPiece = null;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        const dropDestinationCoordinates = [parseInt(matrix.m41 / mainBoardUnitLength + 3), 4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)];
                        pawn.style.transform = `translate(${(parseInt(matrix.m41 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px, ${(parseInt(matrix.m42 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px)`;
                        console.log(`Picked up a piece at ${pieceStartingBoardCoordinates}`);
                        console.log(`Want to place piece at ${dropDestinationCoordinates}`);
                        // If there is a piece here already, move it off the board
                        let capturedSvg = null;
                        for (let letter of ["a", "b"]) {
                            for (let i = 0; i <= 4; i++) {
                                const idOfPotentiallyCapturedPiece = `${letter}${i}`;
                                if (idOfPotentiallyCapturedPiece === pawn.id) continue;
                                const potentiallyCapturedSvg = document.getElementById(idOfPotentiallyCapturedPiece);
                                const coordinates = getSvgPositionAsBoardCoordinates(potentiallyCapturedSvg);
                                if (coordinates[0] === dropDestinationCoordinates[0] && coordinates[1] === dropDestinationCoordinates[1]) {
                                    // There is a piece in the destination square. We can't capture it yet, because
                                    // we aren't sure that this is a legal move. Later we'll check if the board is
                                    // being edited or if this is a legal move, and in either case we'll complete the
                                    // capture.
                                    capturedSvg = potentiallyCapturedSvg;
                                    break;
                                }
                            }
                        }
                        if (!isLockedIn) {
                            // Since the board is being edited, we can skip checking if the move was legal and just
                            // remove the covered piece from the board.
                            if (capturedSvg) capturedSvg.style.transform = getBoardCoordinatesAsSvgTransform(5, 0);
                            return;
                        };
                        const destinationCoordinates = [parseInt(matrix.m41 / mainBoardUnitLength + 3), 4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)];
                        const destinationCoordinatesAsString = `${destinationCoordinates[0]},${destinationCoordinates[1]}`;
                        const relativeMoveAttempted = [parseInt(matrix.m41 / mainBoardUnitLength + 3) - pieceStartingBoardCoordinates[0], 4 - parseInt(matrix.m42 / mainBoardUnitLength + 3) - pieceStartingBoardCoordinates[1]];
                        // TODO if the blue player is making the move, reflect the coordinates of the relative move computed above
                        if (game.playerTurnIndex) {
                            relativeMoveAttempted[0] *= -1;
                            relativeMoveAttempted[1] *= -1;
                        }
                        console.log(`Relative move attempted was ${relativeMoveAttempted}`);
                        console.log(`The selected move allows ${game.serialToRelativeMoveMap[selectedMove]}`);
                        let wasRelativeMoveFound = false;
                        for (let relativeMove of game.serialToRelativeMoveMap[selectedMove]) {
                            if (relativeMove[0] === relativeMoveAttempted[0] && relativeMove[1] === relativeMoveAttempted[1]) {
                                wasRelativeMoveFound = true;
                                console.log(game.squareToSerialMap);
                                const moveString = [pawn.id, selectedMove, game.cMove, relativeMoveAttempted, game.squareToSerialMap[destinationCoordinatesAsString] ? game.squareToSerialMap[destinationCoordinatesAsString] : null];
                                console.log(`Would submit this turn ${moveString}`);
                                let legalMoves = game.getMoves();
                                let didFindMatchingLegalMove = false;
                                for (let move of legalMoves) {
                                    if (doMovesMatch(move, moveString)) {
                                        didFindMatchingLegalMove = true;
                                        break;
                                    }
                                }
                                if (didFindMatchingLegalMove) {
                                    console.log("That is a legal move!");
                                    // Delete any stale future move history
                                    moveHistory.splice(moveCount[0], moveHistory.length - moveCount[0]);
                                    moveHistory.push(moveString);
                                    moveCount[0]++;
                                    if (capturedSvg) capturedSvg.style.transform = getBoardCoordinatesAsSvgTransform(5, 0);
                                    hideMoveAnnotation();
                                    game.makeMove(moveString);
                                    // Sync the UI with the new game state
                                    redrawMovesBasedOnCurrentMap();
                                    applyGamePiecePositionsToUi();
                                    // Schedule print of move suggestion
                                    setTimeout(() => {
                                        if ((game.playerTurnIndex === 0 && showSuggestionsForRed.checked) || (game.playerTurnIndex === 1 && showSuggestionsForBlue.checked)) {
                                            produceComputerSuggestion();
                                        }
                                    }, 25);
                                    selectedMove = null;
                                    sendMessage("Select a move from the moves on the left.", true);
                                    selectedMoveArrow.style.display = "none";
                                } else {
                                    console.warn(`Did not find that in the list of legal moves: ${legalMoves}`);
                                    return;
                                }
                                break;
                            }
                        }
                        if (!wasRelativeMoveFound) {
                            sendMessage("That piece cannot move there using the move you have selected.");
                            pawn.style.transform = getBoardCoordinatesAsSvgTransform(pieceStartingBoardCoordinates[0], pieceStartingBoardCoordinates[1]);
                        }
                    };
                    pawn.addEventListener("mouseup", mouseup);
                    pawn.addEventListener("touchend", (e) => {
                        e.preventDefault();
                        mouseup();
                    });
                    document.body.insertBefore(pawn, moveSuggestionCircle);
                }
            }

            commitMovesButton.addEventListener("click", () => {
        
                if (!isLockedIn) {
                    // Nothing to do
                    commitMovesButton.innerHTML = "Edit game";
                    selectedMoveArrow.style.display = "none";
                    selectedMove = null;
                    // construct moves from the move svgs
                    moveArrayForGameInstantiation = [];
                    for (let k = 0; k <= 4; k++) {
                        const relativeMoveArray = [];
                        for (let i = 0; i <= 4; i++) {
                            for (let j = 0; j <= 4; j++) {
                                const svg = document.getElementById(`moveDrawingSquare-${4 - k},${i},${j}`);
                                if (svg.querySelector("path").getAttribute("fill") === "#77A") {
                                    // We want the center move drawing to be ultimately coded as the cMove, 
                                    // which means it needs to be last in the constructor arguments. So,
                                    // once we have iterated up to k === 2 (the cMove), we will start inserting
                                    // subsequent moves before the cMove so that it is last.
                                    relativeMoveArray.push([i - 2, 2 - j]);
                                }
                            }
                        }
                        if (k > 2) {
                            moveArrayForGameInstantiation.splice(k - 1, 0, relativeMoveArray);
                        } else {
                            moveArrayForGameInstantiation.push(relativeMoveArray);
                        }
                    }
                    // instantiate the game
                    game = new MartialArtsChess(moveArrayForGameInstantiation);
                    game.treeSearchMaxDepth = 6;
                    applyUiPiecePositionsToGame();
                    redrawMovesBasedOnCurrentMap();
                    if (game && game.playerTurnIndex === 0 && showSuggestionsForRed.checked) {
                        produceComputerSuggestion();
                    }
                    sendMessage(`The game is now active. It is the ${(game.playerTurnIndex ? "blue" : "red")} player's turn. Select a move from the ${game.playerTurnIndex ? "blue" : "red"} box on the right.`);
                } else {
                    sendMessage("The game is now in edit mode. You can edit moves or change where pieces are on the board. Pieces can be placed off the board to its right.");
                    commitMovesButton.innerHTML = "Commit game state";
                }
                isLockedIn = !isLockedIn;

            });

            function applyUiPiecePositionsToGame() {
                // First, we need to empty the maps since we'll manually add everything
                for (let key of Object.keys(game.aSerialToSquareMap)) {
                    delete game.aSerialToSquareMap[key];
                }
                for (let key of Object.keys(game.bSerialToSquareMap)) {
                    delete game.bSerialToSquareMap[key];
                }
                for (let key of Object.keys(game.squareToSerialMap)) {
                    delete game.squareToSerialMap[key];
                }
                for (let i = 0; i <= 4; i++) {
                    const pieceSerial = `a${i}`;
                    const aPiece = document.getElementById(pieceSerial);
                    const boardCoordinates = getSvgPositionAsBoardCoordinates(aPiece);
                    if (boardCoordinates[0] >= 0 && boardCoordinates[0] <= 4 && boardCoordinates[1] >= 0 && boardCoordinates[1] <= 4) {
                        game.aSerialToSquareMap[pieceSerial] = boardCoordinates;
                        const boardCoordinatesAsString = `${boardCoordinates[0]},${boardCoordinates[1]}`;
                        game.squareToSerialMap[boardCoordinatesAsString] = pieceSerial;
                    } else {
                        // Assume the piece is captured because it is off the board
                    }
                }
                for (let i = 0; i <= 4; i++) {
                    const pieceSerial = `b${i}`;
                    const bPiece = document.getElementById(pieceSerial);
                    const boardCoordinates = getSvgPositionAsBoardCoordinates(bPiece);
                    if (boardCoordinates[0] >= 0 && boardCoordinates[0] <= 4 && boardCoordinates[1] >= 0 && boardCoordinates[1] <= 4) {
                        game.bSerialToSquareMap[pieceSerial] = boardCoordinates;
                        const boardCoordinatesAsString = `${boardCoordinates[0]},${boardCoordinates[1]}`;
                        game.squareToSerialMap[boardCoordinatesAsString] = pieceSerial;
                    } else {
                        // Assume the piece is captured because it is off the board
                    }
                }
            }

            function applyGamePiecePositionsToUi() {
                for (let i = 0; i <= 4; i++) {
                    const aPieceSerial = `a${i}`;
                    const bPieceSerial = `b${i}`;
                    const svgA = document.getElementById(aPieceSerial);
                    if (game.aSerialToSquareMap.hasOwnProperty(aPieceSerial)) {
                        const destinationCoordinates = game.aSerialToSquareMap[aPieceSerial];
                        svgA.style.transform = getBoardCoordinatesAsSvgTransform(destinationCoordinates[0], destinationCoordinates[1]);
                    } else {
                        // Move the piece off-board because it is captured
                        svgA.style.transform = getBoardCoordinatesAsSvgTransform(5, 0);
                    }
                    const svgB = document.getElementById(bPieceSerial);
                    if (game.bSerialToSquareMap.hasOwnProperty(bPieceSerial)) {
                        const destinationCoordinates = game.bSerialToSquareMap[bPieceSerial];
                        svgB.style.transform = getBoardCoordinatesAsSvgTransform(destinationCoordinates[0], destinationCoordinates[1]);
                    } else {
                        // Move the piece off board because it is captured
                        svgB.style.transform = getBoardCoordinatesAsSvgTransform(5, 4);
                    }
                }
            }

            function redrawMovesBasedOnCurrentMap() {

                // Decolor all of them first
                for (let square of document.querySelectorAll(".moveDrawingSquare")) {
                    if (!/.*2,2$/.test(square.id)) {
                        square.querySelector("path").setAttribute("fill", "#FFC");
                    }
                }
                let k = 0;
                for (let move of game.aMoves) {
                    for (let relativeMove of game.serialToRelativeMoveMap[move]) {
                        document.getElementById(`moveDrawingSquare-${4 - k},${2 + relativeMove[0]},${2 - relativeMove[1]}`).querySelector("path").setAttribute("fill", "#77A");
                    }
                    k++;
                }
                for (let relativeMove of game.serialToRelativeMoveMap[game.cMove]) {
                    document.getElementById(`moveDrawingSquare-${4 - k},${2 + relativeMove[0]},${2 - relativeMove[1]}`).querySelector("path").setAttribute("fill", "#77A");
                }
                k++
                for (let move of game.bMoves) {
                    for (let relativeMove of game.serialToRelativeMoveMap[move]) {
                        document.getElementById(`moveDrawingSquare-${4 - k},${2 + relativeMove[0]},${2 - relativeMove[1]}`).querySelector("path").setAttribute("fill", "#77A");
                    }
                    k++;
                }
            }

            function getSvgPositionAsBoardCoordinates(svg) {
                let computedSyle = window.getComputedStyle(svg);
                let matrix = new WebKitCSSMatrix(computedSyle.transform);
                return [parseInt(matrix.m41 / mainBoardUnitLength + 3), 4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)];
            }

            function getBoardCoordinatesAsSvgTransform(i, j) {
                return `translate(${(-2.5 + i) * mainBoardUnitLength}px, ${(1.5 - j) * mainBoardUnitLength}px)`;
            }

            function doMovesMatch(moveA, moveB) {
                return moveA[0] === moveB[0] &&
                    moveA[1] === moveB[1] &&
                    moveA[2] === moveB[2] &&
                    moveA[3][0] === moveB[3][0] &&
                    moveA[3][1] === moveB[3][1] &&
                    moveA[4] === moveB[4] &&
                    moveA.length === moveB.length;
            }

            function produceComputerSuggestion() {
                const moveCountAtOutset = moveCount[0];
                if (game.isGameOver()) return;
                setTimeout(async () => {
                    await produceComputerSuggestionKernel(5, moveCountAtOutset);   
                    if (moveCountAtOutset !== moveCount[0]) return;
                    setTimeout(async () => {
                        await produceComputerSuggestionKernel(6, moveCountAtOutset);
                        if (moveCountAtOutset !== moveCount[0]) return;
                        setTimeout(async () => {
                            await produceComputerSuggestionKernel(7, moveCountAtOutset);
                        }, 0);
                    }, 0);
                }, 0);
            }

            async function produceComputerSuggestionKernel(depth, moveCountAtOutset) {
                // Copy the game so that a fast moving user does not find a game state that is altered
                // by the computer calculating good moves
                const dummyGame = game.copy();
                dummyGame.treeSearchMaxDepth = depth;
                let resultHolder = [0];
                await dummyGame.getBestMoveAsync(resultHolder, () => { return moveCountAtOutset !== moveCount[0]; });
                if (moveCountAtOutset !== moveCount[0]) return;
                const bestMoveAndProbability = resultHolder[0];
                console.log(`bestMoveAndProbability: ${bestMoveAndProbability}`);
                const winProbability = bestMoveAndProbability[1];
                const bestMoveString = bestMoveAndProbability[0];
                const moveUsed = bestMoveString[1];
                adjustEvaluationBarToBlueWinProbability(game.playerTurnIndex ? winProbability : 1 - winProbability);
                console.log(`Player to move has ${winProbability} win probability and should do ${bestMoveString} using ${moveUsed} which is the one with relative moves ${game.serialToRelativeMoveMap[moveUsed]}`);
                const startCoordinates = game.playerTurnIndex ? game.bSerialToSquareMap[bestMoveString[0]] : game.aSerialToSquareMap[bestMoveString[0]];
                if (!startCoordinates) {
                    console.warn(`bestMoveString is ${bestMoveString}`);
                }
                const relativeMove = bestMoveString[3];
                const reflectionMultiplier = game.playerTurnIndex ? -1 : 1;
                const destinationCoordinates = [startCoordinates[0] + reflectionMultiplier * relativeMove[0], startCoordinates[1] + reflectionMultiplier * relativeMove[1]];
                annotateMove(startCoordinates, destinationCoordinates, bestMoveString[1]);
            }

            function annotateMove(startCoordinates, endCoordinates, moveToHighlight) {
                console.log(`Annotating starting coordinates of ${startCoordinates} and end coordinates of ${endCoordinates}}`);
                moveSuggestionCircle.style.display = "block";
                moveSuggestionLine.style.display = "block";
                moveSuggestionBox.style.display = "block";
                const moveSuggestionCirclePath = moveSuggestionCircle.querySelector("circle");
                const moveSuggestionLinePath = moveSuggestionLine.querySelector("path");
                moveSuggestionCirclePath.setAttribute("cx", endCoordinates[0]);
                moveSuggestionCirclePath.setAttribute("cy", 4 - endCoordinates[1]);
                moveSuggestionLinePath.setAttribute("d", `M${startCoordinates[0]} ${4 - startCoordinates[1]}L${endCoordinates[0]} ${4 - endCoordinates[1]}`);
                // TODO annotate the move on the left that was used
                let k = 0;
                if (game.aMoves.includes(moveToHighlight)) k = 4 - game.aMoves.indexOf(moveToHighlight);
                if (game.bMoves.includes(moveToHighlight)) k = 1 - game.bMoves.indexOf(moveToHighlight);
                if (game.cMove === moveToHighlight) k = 3;
                moveSuggestionBox.style.transform = `translate(-${3.5 * moveDrawingSquareUnitLength}px, ${(1.5 + 7 * k) * moveDrawingSquareUnitLength}px)`;
            }

            function hideMoveAnnotation() {
                moveSuggestionCircle.style.display = "none";
                moveSuggestionLine.style.display = "none";
                moveSuggestionBox.style.display = "none";
            }

            function sendMessage(messageText, isQuiet) {
                userMessage.innerHTML = messageText;
                userMessage.style.background = "#FFF";
                if (isQuiet) return;
                setTimeout(() => {
                    userMessage.style.background = "none";
                    setTimeout(() => {
                        userMessage.style.background = "#FFF";
                        setTimeout(() => {
                            userMessage.style.background = "none";
                        }, 250);
                    }, 250);
                }, 250);
            }

            function adjustEvaluationBarToBlueWinProbability(probability) {
                console.log(`Blue win probability: ${probability}`);
                bluePartOfEvaluationBar.querySelector("path").setAttribute("d", `M0 0H10 V${parseInt(probability * 100)} H0 Z`);               
                blueWinProbabilityText.querySelector("text").innerHTML = `${parseInt(probability * 100)}%`;
            }
        </script>
    </body>
</html>