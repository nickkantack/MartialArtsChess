<!DOCTYPE html>
<html>
    <head>
        <title>Player</title>
        <link rel="stylesheet" href="../styles/style.css"/>
        <script src="../scripts/Base.js"></script>
        <script src="../scripts/Game.js"></script>
        <script src="../scripts/MartialArtsChess.js"></script>
    </head>
    <body>
        <button id="commitMoves">Commit moves</button>
        <div id="debug"></div>
        <div id="originDiv"></div>
        <div id="moveDrawingDiv"></div>
        <template id="mainBoardSquareTemplate">
            <svg class="mainBoardSquare" viewBox="0 0 100 100">
                <path stroke="#AA9" stroke-width="3px" fill="#FFC" d="M0 0H100V100H0Z" />
            </svg>
        </template>
        <template id="moveDrawingSquareTemplate">
            <svg class="moveDrawingSquare" viewBox="0 0 100 100">
                <path stroke="#AA9" stroke-width="3px" fill="#FFC" d="M0 0H100V100H0Z" />
            </svg>
        </template>
        <template id="aPawnTemplate">
            <svg class="aPawn">
                <path stroke="#933" stroke-width="3px" fill="#F55" d="M20 20H80V80H20Z" />
            </svg>
        </template>
        <template id="bPawnTemplate">
            <svg class="bPawn">
                <path stroke="#339" stroke-width="3px" fill="#55F" d="M20 20H80V80H20Z" />
            </svg>
        </template>
        <template id="aGuruTemplate">
            <svg class="aGuru">
                <path stroke="#933" stroke-width="3px" fill="#F55" d="M50 20L20 80H80Z" />
            </svg>
        </template>
        <template id="bGuruTemplate">
            <svg class="bGuru">
                <path stroke="#339" stroke-width="3px" fill="#55F" d="M50 20L20 80H80Z" />
            </svg>
        </template>
        <script>
            const debug = document.getElementById("debug");
            const originDiv = document.getElementById("originDiv");
            const moveDrawingDiv = document.getElementById("moveDrawingDiv");
            const mainBoardSquareTemplate = document.getElementById("mainBoardSquareTemplate");
            const moveDrawingSquareTemplate = document.getElementById("moveDrawingSquareTemplate");
            const aPawnTemplate = document.getElementById("aPawnTemplate");
            const bPawnTemplate = document.getElementById("bPawnTemplate");
            const aGuruTemplate = document.getElementById("aGuruTemplate");
            const bGuruTemplate = document.getElementById("bGuruTemplate");
            let currentMouseCoordinatesOverBoard = null;
            let mainBoardUnitLength = 100;
            let moveDrawingSquareUnitLength = 20;

            let selectedPiece = null;

            let moveSerialToRelativeMovesMap = {
                "m0": [],
                "m1": [],
                "m2": [],
                "m3": [],
                "m4": [],
            };

            let game = null;

            document.body.addEventListener("mousemove", (event) => {
                debug.innerHTML = `${event.clientX - originDiv.offsetLeft}, ${event.clientY - originDiv.offsetTop}`;   
                if (mainBoardUnitLength) {
                    currentMouseCoordinatesOverBoard = [parseInt((event.clientX - originDiv.offsetLeft) / mainBoardUnitLength + 2.5),
                        -parseInt((event.clientY - originDiv.offsetTop) / mainBoardUnitLength - 2.5)];
                    debug.innerHTML += `<br/>${currentMouseCoordinatesOverBoard[0]},${currentMouseCoordinatesOverBoard[1]}`;
                }
                if (selectedPiece) {
                    let computedSyle = window.getComputedStyle(selectedPiece);
                    let matrix = new WebKitCSSMatrix(computedSyle.transform);
                    selectedPiece.style.transform = `translate(${matrix.m41 + event.movementX}px, ${matrix.m42 + event.movementY}px)`;
                }
            });

            // Create main board
            for (let i = 0; i <= 4; i++) {
                for (let j = 0; j <= 4; j++) {
                    const mainSquare = mainBoardSquareTemplate.content.cloneNode(true).querySelector(".mainBoardSquare");
                    // TODO support Chrome, which fails getting the unitLength as shown below
                    const unitLength = mainBoardUnitLength;
                    mainSquare.style.transform = `translate(${(-2.5 + i) * unitLength}px, ${(-2.5 + j) * unitLength}px)`;
                    mainSquare.id = `mainSquare-${i},${j}`;
                    document.body.appendChild(mainSquare);
                }
            }

            // Create the move drawing grids
            for (let k = 0; k <= 4; k++) {
                for (let i = 0; i <= 4; i++) {
                    for (let j = 0; j <= 4; j++) {
                        const moveDrawingSquare = moveDrawingSquareTemplate.content.cloneNode(true).querySelector(".moveDrawingSquare");
                        // TODO support Chrome, which fails getting the unitLength as shown below
                        const unitLength = moveDrawingSquareUnitLength;
                        moveDrawingSquare.style.transform = `translate(${(-2.5 + i) * unitLength}px, ${(2.5 + j + 7 * k) * unitLength}px)`;
                        moveDrawingSquare.id = `moveDrawingSquare-${k},${i},${j}`;
                        if (i === 2 && j === 2) {
                            moveDrawingSquare.querySelector("path").setAttribute("fill", "#333");
                        } else {
                            moveDrawingSquare.addEventListener("mousedown", () => {
                                if (moveSerialToRelativeMovesMap[`m${k}`].includes(`${i-2},${j-2}`)) {
                                    moveSerialToRelativeMovesMap[`m${k}`].splice(moveSerialToRelativeMovesMap[`m${k}`].indexOf(`${i-2},${j-2}`), 1);
                                    moveDrawingSquare.querySelector("path").setAttribute("fill", "#FFC");
                                } else {
                                    moveSerialToRelativeMovesMap[`m${k}`].push(`${i-2},${j-2}`);
                                    moveDrawingSquare.querySelector("path").setAttribute("fill", "#77A");
                                }
                                console.log(moveSerialToRelativeMovesMap);
                            });
                        }
                        moveDrawingDiv.appendChild(moveDrawingSquare);
                    }
                }
            }
            
            // Create the a pieces
            for (let i = 0; i <= 4; i++) {
                if (i === 2) {
                    const pawn = aGuruTemplate.content.cloneNode(true).querySelector(".aGuru");
                    const mainSquare = document.getElementById(`mainSquare-${i},4`);
                    pawn.style.transform = `translate(${(-2.5 + i) * mainBoardUnitLength}px, ${(-2.5 + 4) * mainBoardUnitLength}px)`;
                    pawn.addEventListener("mousedown", (event) => {
                        selectedPiece = pawn;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${matrix.m41 + event.offsetX - (pawn.getBoundingClientRect().right - pawn.getBoundingClientRect().left) / 2}px, ${matrix.m42 + event.offsetY - (pawn.getBoundingClientRect().bottom - pawn.getBoundingClientRect().top) / 2}px)`;
                    });
                    pawn.addEventListener("mouseup", () => {
                        selectedPiece = null;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${(parseInt(matrix.m41 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px, ${(parseInt(matrix.m42 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px)`;
                        console.log(`Want to place piece at ${parseInt(matrix.m41 / mainBoardUnitLength + 3)}, ${4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)}`);
                    });
                    document.body.appendChild(pawn);
                } else {
                    // Make a pawn
                    const pawn = aPawnTemplate.content.cloneNode(true).querySelector(".aPawn");
                    const mainSquare = document.getElementById(`mainSquare-${i},4`);
                    pawn.style.transform = `translate(${(-2.5 + i) * mainBoardUnitLength}px, ${(-2.5 + 4) * mainBoardUnitLength}px)`;
                    pawn.addEventListener("mousedown", (event) => {
                        selectedPiece = pawn;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${matrix.m41 + event.offsetX - (pawn.getBoundingClientRect().right - pawn.getBoundingClientRect().left) / 2}px, ${matrix.m42 + event.offsetY - (pawn.getBoundingClientRect().bottom - pawn.getBoundingClientRect().top) / 2}px)`;
                    });
                    pawn.addEventListener("mouseup", () => {
                        selectedPiece = null;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${(parseInt(matrix.m41 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px, ${(parseInt(matrix.m42 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px)`;
                        console.log(`Want to place piece at ${parseInt(matrix.m41 / mainBoardUnitLength + 3)}, ${4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)}`);
                    });
                    document.body.appendChild(pawn);
                }
            }
            // Create the b pieces
            for (let i = 0; i <= 4; i++) {
                if (i === 2) {
                    const pawn = bGuruTemplate.content.cloneNode(true).querySelector(".bGuru");
                    const mainSquare = document.getElementById(`mainSquare-${i},4`);
                    pawn.style.transform = `translate(${(-2.5 + i) * mainBoardUnitLength}px, ${(-2.5 + 0) * mainBoardUnitLength}px)`;
                    pawn.addEventListener("mousedown", (event) => {
                        selectedPiece = pawn;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${matrix.m41 + event.offsetX - (pawn.getBoundingClientRect().right - pawn.getBoundingClientRect().left) / 2}px, ${matrix.m42 + event.offsetY - (pawn.getBoundingClientRect().bottom - pawn.getBoundingClientRect().top) / 2}px)`;
                    });
                    pawn.addEventListener("mouseup", () => {
                        selectedPiece = null;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        console.log(`Want to place piece at ${parseInt(matrix.m41 / mainBoardUnitLength + 3)}, ${4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)}`);
                        pawn.style.transform = `translate(${(parseInt(matrix.m41 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px, ${(parseInt(matrix.m42 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px)`;
                    });
                    document.body.appendChild(pawn);
                } else {
                    // Make a pawn
                    const pawn = bPawnTemplate.content.cloneNode(true).querySelector(".bPawn");
                    const mainSquare = document.getElementById(`mainSquare-${i},0`);
                    pawn.style.transform = `translate(${(-2.5 + i) * mainBoardUnitLength}px, ${(-2.5 + 0) * mainBoardUnitLength}px)`;
                    pawn.addEventListener("mousedown", () => {
                        selectedPiece = pawn;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${matrix.m41 + event.offsetX - (pawn.getBoundingClientRect().right - pawn.getBoundingClientRect().left) / 2}px, ${matrix.m42 + event.offsetY - (pawn.getBoundingClientRect().bottom - pawn.getBoundingClientRect().top) / 2}px)`;
                    });
                    pawn.addEventListener("mouseup", () => {
                        selectedPiece = null;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        console.log(`Want to place piece at ${parseInt(matrix.m41 / mainBoardUnitLength + 3)}, ${4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)}`);
                        pawn.style.transform = `translate(${(parseInt(matrix.m41 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px, ${(parseInt(matrix.m42 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px)`;
                    });
                    document.body.appendChild(pawn);
                }
            }

            function redrawMovesBasedOnCurrentMap() {

            }
        </script>
    </body>
</html>