<!DOCTYPE html>
<html>
    <head>
        <title>Player</title>
        <link rel="stylesheet" href="../styles/style.css"/>
        <script src="../scripts/Base.js"></script>
        <script src="../scripts/Game.js"></script>
        <script src="../scripts/MartialArtsChess.js"></script>
    </head>
    <body>
        <button id="commitMoves">Commit moves</button>
        <div id="debug"></div>
        <div id="originDiv"></div>
        <div id="moveDrawingDiv"></div>
        <template id="mainBoardSquareTemplate">
            <svg class="mainBoardSquare" viewBox="0 0 100 100">
                <path stroke="#AA9" stroke-width="3px" fill="#FFC" d="M0 0H100V100H0Z" />
            </svg>
        </template>
        <template id="moveDrawingSquareTemplate">
            <svg class="moveDrawingSquare" viewBox="0 0 100 100">
                <path stroke="#AA9" stroke-width="3px" fill="#FFC" d="M0 0H100V100H0Z" />
            </svg>
        </template>
        <template id="aPawnTemplate">
            <svg class="aPawn">
                <path stroke="#933" stroke-width="3px" fill="#F55" d="M20 20H80V80H20Z" />
            </svg>
        </template>
        <template id="bPawnTemplate">
            <svg class="bPawn">
                <path stroke="#339" stroke-width="3px" fill="#55F" d="M20 20H80V80H20Z" />
            </svg>
        </template>
        <template id="aGuruTemplate">
            <svg class="aGuru">
                <path stroke="#933" stroke-width="3px" fill="#F55" d="M50 20L20 80H80Z" />
            </svg>
        </template>
        <template id="bGuruTemplate">
            <svg class="bGuru">
                <path stroke="#339" stroke-width="3px" fill="#55F" d="M50 20L20 80H80Z" />
            </svg>
        </template>
        <script>
            const debug = document.getElementById("debug");
            const originDiv = document.getElementById("originDiv");
            const moveDrawingDiv = document.getElementById("moveDrawingDiv");
            const mainBoardSquareTemplate = document.getElementById("mainBoardSquareTemplate");
            const moveDrawingSquareTemplate = document.getElementById("moveDrawingSquareTemplate");
            const aPawnTemplate = document.getElementById("aPawnTemplate");
            const bPawnTemplate = document.getElementById("bPawnTemplate");
            const aGuruTemplate = document.getElementById("aGuruTemplate");
            const bGuruTemplate = document.getElementById("bGuruTemplate");
            const commitMovesButton = document.getElementById("commitMoves");
            let currentMouseCoordinatesOverBoard = null;
            let mainBoardUnitLength = 100;
            let moveDrawingSquareUnitLength = 20;

            let pieceStartingBoardCoordinates = null;
            let selectedPiece = null;
            let selectedMove = null;

            let game = null;

            let isLockedIn = false;

            document.body.addEventListener("mousemove", (event) => {
                debug.innerHTML = `${event.clientX - originDiv.offsetLeft}, ${event.clientY - originDiv.offsetTop}`;   
                if (mainBoardUnitLength) {
                    currentMouseCoordinatesOverBoard = [parseInt((event.clientX - originDiv.offsetLeft) / mainBoardUnitLength + 2.5),
                        -parseInt((event.clientY - originDiv.offsetTop) / mainBoardUnitLength - 2.5)];
                    debug.innerHTML += `<br/>${currentMouseCoordinatesOverBoard[0]},${currentMouseCoordinatesOverBoard[1]}`;
                }
                if (selectedPiece) {
                    let computedSyle = window.getComputedStyle(selectedPiece);
                    let matrix = new WebKitCSSMatrix(computedSyle.transform);
                    selectedPiece.style.transform = `translate(${matrix.m41 + event.movementX}px, ${matrix.m42 + event.movementY}px)`;
                }
            });

            // Create main board
            for (let i = 0; i <= 4; i++) {
                for (let j = 0; j <= 4; j++) {
                    const mainSquare = mainBoardSquareTemplate.content.cloneNode(true).querySelector(".mainBoardSquare");
                    // TODO support Chrome, which fails getting the unitLength as shown below
                    const unitLength = mainBoardUnitLength;
                    mainSquare.style.transform = `translate(${(-2.5 + i) * unitLength}px, ${(-2.5 + j) * unitLength}px)`;
                    mainSquare.id = `mainSquare-${i},${j}`;
                    document.body.appendChild(mainSquare);
                }
            }

            // Create the move drawing grids
            for (let k = 0; k <= 4; k++) {
                for (let i = 0; i <= 4; i++) {
                    for (let j = 0; j <= 4; j++) {
                        const moveDrawingSquare = moveDrawingSquareTemplate.content.cloneNode(true).querySelector(".moveDrawingSquare");
                        // TODO support Chrome, which fails getting the unitLength as shown below
                        const unitLength = moveDrawingSquareUnitLength;
                        moveDrawingSquare.style.transform = `translate(${(-2.5 + i) * unitLength}px, ${(2.5 + j + 7 * k) * unitLength}px)`;
                        moveDrawingSquare.id = `moveDrawingSquare-${k},${i},${j}`;
                        if (i === 2 && j === 2) {
                            moveDrawingSquare.querySelector("path").setAttribute("fill", "#333");
                        } else {
                            moveDrawingSquare.addEventListener("mousedown", () => {
                                if (isLockedIn) {
                                    if (k >= 3) {
                                        selectedMove = `m${4 - k}`;
                                        console.log(`Selected move ${selectedMove}`);
                                    } else {
                                        console.warn("You are not allowed to select that move as the red player.");
                                    }
                                } else {
                                    if (moveDrawingSquare.querySelector("path").getAttribute("fill") === "#77A") {
                                        moveDrawingSquare.querySelector("path").setAttribute("fill", "#FFC");
                                    } else {
                                        moveDrawingSquare.querySelector("path").setAttribute("fill", "#77A");
                                    }
                                }
                            });
                        }
                        moveDrawingDiv.appendChild(moveDrawingSquare);
                    }
                }
            }
            
            // Create the a pieces
            for (let i = 0; i <= 4; i++) {
                if (i === 2) {
                    const pawn = aGuruTemplate.content.cloneNode(true).querySelector(".aGuru");
                    pawn.id = `a${i}`;
                    const mainSquare = document.getElementById(`mainSquare-${i},4`);
                    pawn.style.transform = `translate(${(-2.5 + i) * mainBoardUnitLength}px, ${(-2.5 + 4) * mainBoardUnitLength}px)`;
                    pawn.addEventListener("mousedown", (event) => {
                        if (isLockedIn && !selectedMove) {
                            console.warn("You must select a move before manipulating a piece.");
                            return;
                        }
                        selectedPiece = pawn;
                        pieceStartingBoardCoordinates = getSvgPositionAsBoardCoordinates(pawn);
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${matrix.m41 + event.offsetX - (pawn.getBoundingClientRect().right - pawn.getBoundingClientRect().left) / 2}px, ${matrix.m42 + event.offsetY - (pawn.getBoundingClientRect().bottom - pawn.getBoundingClientRect().top) / 2}px)`;
                    });
                    pawn.addEventListener("mouseup", () => {
                        if (isLockedIn && !selectedMove) {
                            return;
                        }
                        selectedPiece = null;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${(parseInt(matrix.m41 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px, ${(parseInt(matrix.m42 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px)`;
                        console.log(`Want to place piece at ${parseInt(matrix.m41 / mainBoardUnitLength + 3)}, ${4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)}`);
                        // TODO check if this is a legal move
                    });
                    document.body.appendChild(pawn);
                } else {
                    // Make a pawn
                    const pawn = aPawnTemplate.content.cloneNode(true).querySelector(".aPawn");
                    pawn.id = `a${i}`;
                    const mainSquare = document.getElementById(`mainSquare-${i},4`);
                    pawn.style.transform = `translate(${(-2.5 + i) * mainBoardUnitLength}px, ${(-2.5 + 4) * mainBoardUnitLength}px)`;
                    pawn.addEventListener("mousedown", (event) => {
                        if (isLockedIn && !selectedMove) {
                            console.warn("You must select a move before manipulating a piece.");
                            return;
                        }
                        selectedPiece = pawn;
                        pieceStartingBoardCoordinates = getSvgPositionAsBoardCoordinates(pawn);
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${matrix.m41 + event.offsetX - (pawn.getBoundingClientRect().right - pawn.getBoundingClientRect().left) / 2}px, ${matrix.m42 + event.offsetY - (pawn.getBoundingClientRect().bottom - pawn.getBoundingClientRect().top) / 2}px)`;
                    });
                    pawn.addEventListener("mouseup", () => {
                        if (isLockedIn && !selectedMove) {
                            return;
                        }
                        selectedPiece = null;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${(parseInt(matrix.m41 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px, ${(parseInt(matrix.m42 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px)`;
                        console.log(`Picked up a piece at ${pieceStartingBoardCoordinates}`);
                        console.log(`Want to place piece at ${parseInt(matrix.m41 / mainBoardUnitLength + 3)}, ${4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)}`);
                        const destinationCoordinates = [parseInt(matrix.m41 / mainBoardUnitLength + 3), 4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)];
                        const destinationCoordinatesAsString = `${destinationCoordinates[0]},${destinationCoordinates[1]}`;
                        const relativeMoveAttempted = [parseInt(matrix.m41 / mainBoardUnitLength + 3) - pieceStartingBoardCoordinates[0], 4 - parseInt(matrix.m42 / mainBoardUnitLength + 3) - pieceStartingBoardCoordinates[1]];
                        let wasRelativeMoveFound = false;
                        for (let relativeMove of game.serialToRelativeMoveMap[selectedMove]) {
                            if (relativeMove[0] === relativeMoveAttempted[0] && relativeMove[1] === relativeMoveAttempted[1]) {
                                wasRelativeMoveFound = true;
                                const moveString = [pawn.id, selectedMove, game.cMove, relativeMoveAttempted, destinationCoordinates, game.squareToSerialMap[destinationCoordinatesAsString] ? game.squareToSerialMap[destinationCoordinatesAsString] : null];
                                console.log(`Would submit this turn ${moveString}`);
                                // TODO make the move string, submit it to the game, then trigger AI move
                                break;
                            }
                        }
                        if (!wasRelativeMoveFound) {
                            console.warn("You are not allowed to make that move");
                            pawn.style.transform = getBoardCoordinatesAsSvgTransform(pieceStartingBoardCoordinates);
                        }
                    });
                    document.body.appendChild(pawn);
                }
            }
            // Create the b pieces
            for (let i = 0; i <= 4; i++) {
                if (i === 2) {
                    const pawn = bGuruTemplate.content.cloneNode(true).querySelector(".bGuru");
                    pawn.id = `b${i}`;
                    const mainSquare = document.getElementById(`mainSquare-${i},4`);
                    pawn.style.transform = `translate(${(-2.5 + i) * mainBoardUnitLength}px, ${(-2.5 + 0) * mainBoardUnitLength}px)`;
                    pawn.addEventListener("mousedown", (event) => {
                        if (isLockedIn) {
                            console.warn("These are your opponent's pieces which can only be moved in edit mode.");
                            return;
                        }
                        selectedPiece = pawn;
                        pieceStartingBoardCoordinates = getSvgPositionAsBoardCoordinates(pawn);
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${matrix.m41 + event.offsetX - (pawn.getBoundingClientRect().right - pawn.getBoundingClientRect().left) / 2}px, ${matrix.m42 + event.offsetY - (pawn.getBoundingClientRect().bottom - pawn.getBoundingClientRect().top) / 2}px)`;
                    });
                    pawn.addEventListener("mouseup", () => {
                        if (isLockedIn) {
                            return;
                        }
                        selectedPiece = null;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        console.log(`Want to place piece at ${parseInt(matrix.m41 / mainBoardUnitLength + 3)}, ${4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)}`);
                        pawn.style.transform = `translate(${(parseInt(matrix.m41 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px, ${(parseInt(matrix.m42 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px)`;
                    });
                    document.body.appendChild(pawn);
                } else {
                    // Make a pawn
                    const pawn = bPawnTemplate.content.cloneNode(true).querySelector(".bPawn");
                    pawn.id = `b${i}`;
                    const mainSquare = document.getElementById(`mainSquare-${i},0`);
                    pawn.style.transform = `translate(${(-2.5 + i) * mainBoardUnitLength}px, ${(-2.5 + 0) * mainBoardUnitLength}px)`;
                    pawn.addEventListener("mousedown", (event) => {
                        if (isLockedIn) {
                            console.warn("These are your opponent's pieces which can only be moved in edit mode.");
                            return;
                        }
                        selectedPiece = pawn;
                        pieceStartingBoardCoordinates = getSvgPositionAsBoardCoordinates(pawn);
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        pawn.style.transform = `translate(${matrix.m41 + event.offsetX - (pawn.getBoundingClientRect().right - pawn.getBoundingClientRect().left) / 2}px, ${matrix.m42 + event.offsetY - (pawn.getBoundingClientRect().bottom - pawn.getBoundingClientRect().top) / 2}px)`;
                    });
                    pawn.addEventListener("mouseup", () => {
                        if (isLockedIn) {
                            return;
                        }
                        selectedPiece = null;
                        let computedSyle = window.getComputedStyle(pawn);
                        let matrix = new WebKitCSSMatrix(computedSyle.transform);
                        console.log(`Want to place piece at ${parseInt(matrix.m41 / mainBoardUnitLength + 3)}, ${4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)}`);
                        pawn.style.transform = `translate(${(parseInt(matrix.m41 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px, ${(parseInt(matrix.m42 / mainBoardUnitLength + 3) - 2.5) * mainBoardUnitLength}px)`;
                    });
                    document.body.appendChild(pawn);
                }
            }

            commitMoves.addEventListener("click", () => {
        
                if (isLockedIn) {
                    // Nothing to do
                    commitMoves.innerHTML = "Edit game";
                } else {
                    // TODO construct moves from the move svgs
                    const moveArrayForGameInstantiation = [];
                    for (let k = 0; k <= 4; k++) {
                        const relativeMoveArray = [];
                        for (let i = 0; i <= 4; i++) {
                            for (let j = 0; j <= 4; j++) {
                                const svg = document.getElementById(`moveDrawingSquare-${4 - k},${i},${j}`);
                                if (svg.querySelector("path").getAttribute("fill") === "#77A") {
                                    // We want the center move drawing to be ultimately coded as the cMove, 
                                    // which means it needs to be last in the constructor arguments. So,
                                    // once we have iterated up to k === 2 (the cMove), we will start inserting
                                    // subsequent moves before the cMove so that it is last.
                                    if (k > 2) {
                                        relativeMoveArray.splice(2, 0, [i - 2, 2 - j]);
                                    } else {
                                        relativeMoveArray.push([i - 2, 2 - j]);
                                    }
                                }
                            }
                        }
                        moveArrayForGameInstantiation.push(relativeMoveArray);
                    }
                    // instantiate the game
                    game = new MartialArtsChess(moveArrayForGameInstantiation);
                    applyUiPiecePositionsToGame();
                    commitMoves.innerHTML = "Commit game state";
                }
                isLockedIn = !isLockedIn;

            });

            function applyUiPiecePositionsToGame() {
                // First, we need to empty the maps since we'll manually add everything
                for (let key of Object.keys(game.aSerialToSquareMap)) {
                    delete game.aSerialToSquareMap[key];
                }
                for (let key of Object.keys(game.bSerialToSquareMap)) {
                    delete game.bSerialToSquareMap[key];
                }
                for (let key of Object.keys(game.squareToSerialMap)) {
                    delete game.squareToSerialMap[key];
                }
                for (let i = 0; i <= 4; i++) {
                    const pieceSerial = `a${i}`;
                    const aPiece = document.getElementById(pieceSerial);
                    const boardCoordinates = getSvgPositionAsBoardCoordinates(aPiece);
                    if (boardCoordinates[0] >= 0 && boardCoordinates[0] <= 4 && boardCoordinates[1] >= 0 && boardCoordinates[1] <= 4) {
                        game.aSerialToSquareMap[pieceSerial] = boardCoordinates;
                        const boardCoordinatesAsString = `${boardCoordinates[0]},${boardCoordinates[1]}`;
                        game.squareToSerialMap[boardCoordinatesAsString] = pieceSerial;
                    } else {
                        // Assume the piece is captured because it is off the board
                    }
                }
                for (let i = 0; i <= 4; i++) {
                    const pieceSerial = `b${i}`;
                    const bPiece = document.getElementById(pieceSerial);
                    const boardCoordinates = getSvgPositionAsBoardCoordinates(bPiece);
                    if (boardCoordinates[0] >= 0 && boardCoordinates[0] <= 4 && boardCoordinates[1] >= 0 && boardCoordinates[1] <= 4) {
                        game.bSerialToSquareMap[pieceSerial] = boardCoordinates;
                        const boardCoordinatesAsString = `${boardCoordinates[0]},${boardCoordinates[1]}`;
                        game.squareToSerialMap[boardCoordinatesAsString] = pieceSerial;
                    } else {
                        // Assume the piece is captured because it is off the board
                    }
                }
            }

            function applyGamePiecePositionsToUi() {
                for (let i = 0; i <= 4; i++) {
                    const aPieceSerial = `a${i}`;
                    const bPieceSerial = `b${i}`;
                    if (game.aSerialToSquareMap.hasOwnProperty(aPieceSerial)) {
                        const svg = document.getElementById(aPieceSerial);
                        svg.style.transform = getBoardCoordinatesAsSvgTransform(game.aSerialToSquareMap[aPieceSerial]);
                    } else {
                        // The piece is captured and we'll let it stay wherever it is in the UI
                    }
                    if (game.bSerialToSquareMap.hasOwnProperty(bPieceSerial)) {
                        const svg = document.getElementById(bPieceSerial);
                        svg.style.transform = getBoardCoordinatesAsSvgTransform(game.bSerialToSquareMap[bPieceSerial]);
                    } else {
                        // The piece is captured and we'll let it stay wherever it is in the UI
                    }
                }
            }

            function redrawMovesBasedOnCurrentMap() {
                // Decolor all of them first
                for (let square of document.querySelectorAll(".moveDrawingSquare")) {
                    square.querySelector("path").setAttribute("fill", "#FFC");
                }
                let k = 0;
                for (let move of game.aMoves) {
                    for (let relativeMove of move) {
                        document.getElementById(`moveDrawingSquare-${4 - k},${relativeMove[0]},${4 - relativeMove[1]}`).setAttribute("fill", "#77A");
                    }
                    k++;
                }
                for (let relativeMove of game.cMove) {
                    document.getElementById(`moveDrawingSquare-${4 - k},${relativeMove[0]},${4 - relativeMove[1]}`).setAttribute("fill", "#77A");
                }
                for (let move of game.bMoves) {
                    for (let relativeMove of move) {
                        document.getElementById(`moveDrawingSquare-${4 - k},${relativeMove[0]},${4 - relativeMove[1]}`).setAttribute("fill", "#77A");
                    }
                    k++;
                }
            }

            function getSvgPositionAsBoardCoordinates(svg) {
                let computedSyle = window.getComputedStyle(svg);
                let matrix = new WebKitCSSMatrix(computedSyle.transform);
                return [parseInt(matrix.m41 / mainBoardUnitLength + 3), 4 - parseInt(matrix.m42 / mainBoardUnitLength + 3)];
            }

            function getBoardCoordinatesAsSvgTransform(i, j) {
                return `translate(${(-2.5 + i) * mainBoardUnitLength}px, ${(-2.5 + j) * mainBoardUnitLength}px)`;
            }
        </script>
    </body>
</html>